// Ported from https://github.com/medikoo/plain-promise;

export class TSPromise<R> {

    /**
     * Holds the callback functions for then and catch
     * 
     * @internal
     * @type {Array<any>}
     * @memberOf TSPromise
     */
    private _callbacks: Array<any>;

    /**
     * Set to true once the promise is in a fail state
     * 
     * @internal
     * @type {Boolean}
     * @memberOf TSPromise
     */
    private _failed: Boolean;

    /**
     * Set to true once the promise has resolved
     * 
     * @internal
     * @type {Boolean}
     * @memberOf TSPromise
     */
    private _resolved: Boolean;

    /**
     * Set to true once the promise has settled
     * 
     * @internal
     * @type {Boolean}
     * @memberOf TSPromise
     */
    private _settled: Boolean;

    /**
     * The final result value of the promise
     * 
     * @internal
     * @type {R}
     * @memberOf TSPromise
     */
    private _value: R;

    private _scope: any;

    constructor(callFunc?: (resolve?: Function, reject?: Function) => void, scope?: any) {
        this._callbacks = [];
        this._failed = false;
        this._resolved = false;
        this._settled = false;
        this._scope = scope || this;
        callFunc(this._resolve.bind(this), this._reject.bind(this));
    }

    /**
     * Manually resolve the promise.
     * 
     * @static
     * @param {*} value
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static resolve(value: any): TSPromise<any> {
        return new TSPromise(function (resolve) { resolve(value); });
    }

    /**
     * Manually reject the promise.
     * 
     * @static
     * @param {*} error
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static reject(error: any): TSPromise<any> {
        return new TSPromise(function (resolve, reject) { reject(error); });
    }

    /**
     * Provide an array of promises, the first promise to resolve will be passed up with it's result.
     * 
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static race(promises: Array<TSPromise<any>>): TSPromise<any> {
        let complete = false;
        return new TSPromise((resolve, reject) => {
            promises.forEach((p) => {
                p.then((res) => {
                    if (!complete) resolve(res), complete = true;
                }).catch((error)  => {
                    reject(error); complete = true;
                });
            });
        });
    }

    /**
     * Chain pomises together sequentially
     * 
     * @static
     * @param {Array<TSPromise<any>} promises
     * @returns {TSPromise<any>}
     * 
     * @memberOf TSPromise
     */
    public static chain(promises: Array<TSPromise<any>>): TSPromise<any> {
        let index = 0;
        let resolve;
        let results = [];
        let nextPromise = function(promise) {
            if (index === promises.length) {
                resolve(results);
            } else {
                promise.then(function(result) {
                    results.push(result);
                    index++;
                    nextPromise(promises[index]);
                });
            }
        };
        return new TSPromise((res) => {
            resolve = res;
            nextPromise(promises[index]);
        });
    }

    /**
     * Provide an array of promises, the function will return once every promise has completed.
     * The return array will have it's values in the same position as their originating promise.
     * 
     * @static
     * @param {Array<TSPromise<any>>} promises
     * @returns {TSPromise<Array<any>>}
     * 
     * @memberOf TSPromise
     */
    public static all(promises: Array<TSPromise<any>>): TSPromise<Array<any>> {
        return new TSPromise<Array<any>>((resolve, reject) => {

            let count: number = promises.length;
            let results: Array<any> = [];
            let complete: Boolean = false;

            promises.forEach((p, i) => {
                p.then((res) => {
                    if (!complete) {
                        count--;
                        results[i] = res;
                        if (count === 0) resolve(results);
                    }
                }).catch((error)  => {
                    reject(error); complete = true;
                });
            });
        });
    }

    /**
     * End the promise chain and tidy everything up.
     * 
     * @param {Function} onSuccess
     * @param {Function} onFail
     * 
     * @memberOf TSPromise
     */
    public done(onSuccess: Function, onFail: Function): void {
        if (this._settled) {
            // Do not release before `done` returns
            setTimeout(this._release.bind(this, onSuccess, onFail), 0);
        } else {
            this._callbacks.push({ onSuccess: onSuccess, onFail: onFail });
        }
    }

    /**
     * Take the result of the given promise, also allows chaining of promises.
     * 
     * @param {Function} [onSuccess]
     * @param {Function} [onFail]
     * @returns {TSPromise<R>}
     * 
     * @memberOf TSPromise
     */
    public then(onSuccess?: Function, onFail?: Function): TSPromise<R> {
        let t = this;
        return new TSPromise<R>((resolve, reject) => {
            t.done((value) => {
                if (typeof onSuccess === "function") {
                    try {
                        value = onSuccess.apply(t._scope, [value]);
                    }
                    catch (e) {
                        reject(e);
                        return;
                    }
                }
                resolve(value);
            }, (value) => {
                if (typeof onFail === "function") {
                    try {
                        value = onFail.apply(t._scope, [value]);
                    }
                    catch (e) {
                        reject(e);
                        return;
                    }
                    resolve(value);
                }
                else {
                    reject(value);
                }
            });
        }, t._scope);
    }

    /**
     * Handle exceptions that happen to the promise.
     * 
     * @param {any} onFail
     * @returns {TSPromise<R>}
     * 
     * @memberOf TSPromise
     */
    public catch(onFail): TSPromise<R> {
        return this.then(null, onFail);
    }

    /**
     * The final call for the promise, then/catch -> settle -> release OR done -> release
     * 
     * @internal
     * @param {any} onSuccess
     * @param {any} onFail
     * 
     * @memberOf TSPromise
     */
    private _release(onSuccess, onFail): void {
        if (this._failed) {
            onFail(this._value);
        } else {
            onSuccess(this._value);
        }
    }

    /**
     * Resolve the promise, called to start the process of completeing the promise.
     * 
     * @internal
     * @param {*} value
     * @returns {void}
     * 
     * @memberOf TSPromise
     */
    private _resolve(value: any): void {
        if (this._resolved) return;
        this._resolved = true;
        if (value instanceof TSPromise) {
            value.done(this._settle.bind(this), function (error) {
                this._failed = true;
                this._settle(error);
            }.bind(this));
        } else {
            this._settle(value);
        }
    }

    /**
     * Reject the promise, the first step of completing the promise in a reject state.
     * 
     * @internal
     * @param {*} value
     * @returns {void}
     * 
     * @memberOf TSPromise
     */
    private _reject(value: any): void {
        if (this._resolved) return;
        this._resolved = true;
        this._failed = true;
        this._settle(value);
    }

    /**
     * Final settle function, puts the promise in it's complete state.
     * 
     * @internal
     * @param {*} value
     * 
     * @memberOf TSPromise
     */
    private _settle(value: any): void {
        this._settled = true;
        this._value = value;
        // Do not release before `resolve` or `reject` returns
        setTimeout(this._callbacks.forEach.bind(this._callbacks, function (data) {
            this._release(data.onSuccess, data.onFail);
        }, this), 0);
    }
}